---
layout: post
title: "创建型模式"
date: 2018-08-20
description: "设计模式"
tag: 设计模式
--- 

## 简单工厂模式

1. 内容:不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。

2. 角色
    - 工厂角色(Creator)
    - 抽象产品角色(Product)
    - 具体产品角色(Concrete Product)

3. 优点 
    - 隐藏了对象创建的实现细节
    - 客户端不需要修改代码

4. 缺点
    - 违反了单一职责原则，将创建逻辑集中到一个工厂类里
    - 当添加新产品时，需要修改工厂类代码，违反了开闭原则

## 工厂方法模式

1. 内容:定义一个用于创建对象的接口(工厂接口)，让子类决定实例化哪一个产品类。

2. 角色
    - 抽象工厂角色(Creator)
    - 具体工厂角色(Concrete Creator)
    - 抽象产品角色(Product)
    - 具体产品角色(Concrete Product)

3. 工厂方法模式相比简单工厂模式将每个具体产品都对应了一个具体工厂

4. 适用场景
    - 需要生产多种、大量复杂对象的时候
    - 需要降低耦合的时候
    - 当系统中的产品种类需要经常扩展的时候

5. 优点
    - 每个具体产品都对应一个具体工厂类，不需要修改工厂类代码
    - 隐藏了对象创建的实现细节

6. 缺点
    - 每增加一个具体产品类，就必须增加一个相应的具体工厂类


## 抽象工厂模式

1. 内容:定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象

2. 例子:生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。

3. 角色
    - 抽象工厂角色(Creator)
    - 具体工厂角色(Concrete Creator)
    - 抽象产品角色(Product)
    - 具体产品角色(Concrete Product)
    - 客户端(Client)

4. 相比工厂方法模式，抽象工厂模式的每个具体工厂都生产一套产品。

5. 适用场景
    - 系统要独立于产品的创建与组合时
    - 强调一系列相关的产品对象的设计以便进行联合使用时
    - 提供一个产品类库，想隐藏产品的具体实现时

6. 优点
    - 将客户端与类的具体实现相分离
    - 每个工厂创建了一个完整的产品系列，使得易于交换产品系列
    - 有利于产品的一致性(即产品之间的约束关系)

7. 缺点
    难以支持新种类的(抽象)产品


## 建造者模式

1. 内容:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

2. 角色
    - 抽象建造者(BUilder)
    - 具体建造者(Concrete BUilder)
    - 指挥者(Director)
    - 产品(Product)

3. 建造者模式和抽象工厂模式形似，也用来创建复杂对象。主要区别是建造者模式着重一步步构造一个复杂对象，二抽象工厂模式着重于多个系列的产品对象。

4. 适用场景
    - 当创建复杂对象的算法(Director)应该独立于该对象的组成部分以及它们的装配方式(Builder)时
    - 当构造过程允许被构造的对象有不同的表示时(不同Builder)

5. 优点
    - 隐藏了一个产品的内部结构和装配过程
    - 将构造代码与表示代码分开
    - 可以对构造过程进行更精细的控制


## 单例模式

1. 内容:保证一个类只有一个实例，并提供一个访问它的全局访问点。

2. 角色: 单例(Singleton)

3. 适用场景
    - 当类只有一个实例而且客户可以从一个众所周知的访问点访问它时

4. 优点
    - 对唯一实例的受控访问
    - 单例相当于全局变量，但防止了命名空间被污染

5. 与单例模式功能相似的概念:全局变量、静态方法

```python
class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance


```