---
layout: post
title: "行为型模式"
date: 2018-08-21
description: "设计模式"
tag: 设计模式
--- 

## 责任链模式

1. 内容：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

2. 角色
    - 抽象处理者(Handler)
    - 具体处理者(ConcreteHandler)
    - 客户端(Client)

3. 示例
    - 请假部门批准：leader——部门经理——总经理
    - Javascript事件浮升机制

4. 适用场景
    - 有多个对象可以处理一个请求，哪个对象处理由运行时觉决定
    - 在不明确接受者的情况下，向多个对象中的一个提交一个请求

5. 优点
    - 降低耦合度：一个对象无需知道是其他哪一个对象处理其请求

6. 缺点
    - 请求不保证被接受:链的末端没有处理或链配置错误

## 迭代器模式

1. 内容:提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示

2. 实现方法:__iter__,__next__


## 观察者模式

1. 内容:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者模式又称“发布-订阅”模式

2. 角色
    - 抽象主题(Subject)
    - 具体主题(ConcreteSubject) -- 发布者
    - 抽象观察者(Observer)
    - 具体观察者(ConcreteObserver) -- 订阅者

3. 适用场景
    - 当一个抽象模型有两方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用。
    - 当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
    - 当一个对象必须通知其他对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的

4. 优点
    - 目标和观察者之间的抽象耦合最小
    - 支持广播通信

5. 缺点
    - 多个观察者之间互不知道对方存在，因此一个观察者对主题的修改可能造成错误的更新

## 策略模式

1. 内容：定义一系列的算法，把它们一个个封装起来，并且是它们可互相替换。本模式使得算法可独立于使用它的客户而变化

2. 角色
    - 抽象策略(Strategy)
    - 具体策略(ConcreteStrategy)
    - 上下文(Context)

3. 适用场景
    - 许多相关的类仅仅是行为有异
    - 需要使用一个算法的不同变体
    - 算法使用客户端无需知道的数据
    - 一个类中的多种行为以多个条件语句的形式存在，可以将这些行为封装在不同的策略类中

4. 优点
    - 定义了一系列可重用的算法和行为
    - 消除了一些条件语句
    - 可以提供相同行为的不同实现

5. 缺点
    - 客户必须了解不同的策略
    - 策略与上下文之间的通信开销
    - 增加了对象的数目

## 模板方法模式

1. 内容：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

2. 角色
    - 抽象类(AbstractClass):定义抽象的原子操作(钩子操作)，实现一个模板方法作为算法饿骨架
    - 具体类(ConcreteClass):实现原子操作

3. 适用场景
    - 一次性实现一个算法的不变的部分
    - 各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复
    - 控制子类扩展
    